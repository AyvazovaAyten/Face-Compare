import { __extends } from 'tslib';
import { Observable } from 'rxjs';
import { share } from 'rxjs/operators';
import { InjectionToken, Attribute, Directive, Inject, Optional, ElementRef, Injectable, NgModule, inject } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'rxjs';
var INTERSECTION_ROOT = new InjectionToken('Root element for IntersectionObserver');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var INTERSECTION_ROOT_MARGIN_DEFAULT = '0px 0px 0px 0px';
/** @type {?} */
var INTERSECTION_ROOT_MARGIN = new InjectionToken('rootMargin for IntersectionObserver', {
    providedIn: 'root',
    factory: function () { return INTERSECTION_ROOT_MARGIN_DEFAULT; },
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} rootMargin
 * @return {?}
 */
function rootMarginFactory(rootMargin) {
    return rootMargin || INTERSECTION_ROOT_MARGIN_DEFAULT;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var INTERSECTION_THRESHOLD_DEFAULT = 0;
/** @type {?} */
var INTERSECTION_THRESHOLD = new InjectionToken('threshold for IntersectionObserver', {
    providedIn: 'root',
    factory: function () { return INTERSECTION_THRESHOLD_DEFAULT; },
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} threshold
 * @return {?}
 */
function thresholdFactory(threshold) {
    return threshold
        ? threshold.split(',').map(parseFloat)
        : INTERSECTION_THRESHOLD_DEFAULT;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IntersectionObserverDirective = /** @class */ (function (_super) {
    __extends(IntersectionObserverDirective, _super);
    function IntersectionObserverDirective(root, rootMargin, threshold) {
        var _this = _super.call(this, function (entries) {
            _this.callbacks.forEach(function (callback, element) {
                /** @type {?} */
                var filtered = entries.filter(function (_a) {
                    var target = _a.target;
                    return target === element;
                });
                return filtered.length && callback(filtered, _this);
            });
        }, {
            root: root && root.nativeElement,
            rootMargin: rootMarginFactory(rootMargin),
            threshold: thresholdFactory(threshold),
        }) || this;
        _this.callbacks = new Map();
        return _this;
    }
    /**
     * @param {?} target
     * @param {?=} callback
     * @return {?}
     */
    IntersectionObserverDirective.prototype.observe = /**
     * @param {?} target
     * @param {?=} callback
     * @return {?}
     */
    function (target, callback) {
        if (callback === void 0) { callback = function () { }; }
        _super.prototype.observe.call(this, target);
        this.callbacks.set(target, callback);
    };
    /**
     * @param {?} target
     * @return {?}
     */
    IntersectionObserverDirective.prototype.unobserve = /**
     * @param {?} target
     * @return {?}
     */
    function (target) {
        _super.prototype.unobserve.call(this, target);
        this.callbacks.delete(target);
    };
    /**
     * @return {?}
     */
    IntersectionObserverDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.disconnect();
    };
    /** @nocollapse */
    IntersectionObserverDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INTERSECTION_ROOT,] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['waIntersectionRootMargin',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['waIntersectionThreshold',] }] }
    ]; };
IntersectionObserverDirective.ɵfac = function IntersectionObserverDirective_Factory(t) { return new (t || IntersectionObserverDirective)(ɵngcc0.ɵɵdirectiveInject(INTERSECTION_ROOT, 8), ɵngcc0.ɵɵinjectAttribute('waIntersectionRootMargin'), ɵngcc0.ɵɵinjectAttribute('waIntersectionThreshold')); };
IntersectionObserverDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IntersectionObserverDirective, selectors: [["", "waIntersectionObserver", ""]], exportAs: ["IntersectionObserver"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserverDirective, [{
        type: Directive,
        args: [{
                selector: '[waIntersectionObserver]',
                exportAs: 'IntersectionObserver'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [INTERSECTION_ROOT]
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['waIntersectionRootMargin']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['waIntersectionThreshold']
            }] }]; }, null); })();
    return IntersectionObserverDirective;
}(IntersectionObserver));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IntersectionObserveeService = /** @class */ (function (_super) {
    __extends(IntersectionObserveeService, _super);
    function IntersectionObserveeService(_a, observer) {
        var nativeElement = _a.nativeElement;
        var _this = _super.call(this, function (subscriber) {
            observer.observe(nativeElement, function (entries) {
                subscriber.next(entries);
            });
            return function () {
                observer.unobserve(nativeElement);
            };
        }) || this;
        return _this.pipe(share());
    }
    /** @nocollapse */
    IntersectionObserveeService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: IntersectionObserverDirective, decorators: [{ type: Inject, args: [IntersectionObserverDirective,] }] }
    ]; };
IntersectionObserveeService.ɵfac = function IntersectionObserveeService_Factory(t) { return new (t || IntersectionObserveeService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(IntersectionObserverDirective)); };
IntersectionObserveeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntersectionObserveeService, factory: function (t) { return IntersectionObserveeService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserveeService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }, { type: IntersectionObserverDirective, decorators: [{
                type: Inject,
                args: [IntersectionObserverDirective]
            }] }]; }, null); })();
    return IntersectionObserveeService;
}(Observable));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
var IntersectionObserveeDirective = /** @class */ (function () {
    function IntersectionObserveeDirective(waIntersectionObservee) {
        this.waIntersectionObservee = waIntersectionObservee;
    }
    /** @nocollapse */
    IntersectionObserveeDirective.ctorParameters = function () { return [
        { type: Observable, decorators: [{ type: Inject, args: [IntersectionObserveeService,] }] }
    ]; };
IntersectionObserveeDirective.ɵfac = function IntersectionObserveeDirective_Factory(t) { return new (t || IntersectionObserveeDirective)(ɵngcc0.ɵɵdirectiveInject(IntersectionObserveeService)); };
IntersectionObserveeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IntersectionObserveeDirective, selectors: [["", "waIntersectionObservee", ""]], outputs: { waIntersectionObservee: "waIntersectionObservee" }, features: [ɵngcc0.ɵɵProvidersFeature([IntersectionObserveeService])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserveeDirective, [{
        type: Directive,
        args: [{
                selector: '[waIntersectionObservee]',
                outputs: ['waIntersectionObservee'],
                providers: [IntersectionObserveeService]
            }]
    }], function () { return [{ type: ɵngcc1.Observable, decorators: [{
                type: Inject,
                args: [IntersectionObserveeService]
            }] }]; }, null); })();
    return IntersectionObserveeDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IntersectionRootDirective = /** @class */ (function () {
    function IntersectionRootDirective() {
    }
IntersectionRootDirective.ɵfac = function IntersectionRootDirective_Factory(t) { return new (t || IntersectionRootDirective)(); };
IntersectionRootDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IntersectionRootDirective, selectors: [["", "waIntersectionRoot", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: INTERSECTION_ROOT,
                useExisting: ElementRef
            },
        ])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionRootDirective, [{
        type: Directive,
        args: [{
                selector: '[waIntersectionRoot]',
                providers: [
                    {
                        provide: INTERSECTION_ROOT,
                        useExisting: ElementRef
                    },
                ]
            }]
    }], function () { return []; }, null); })();
    return IntersectionRootDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IntersectionObserverModule = /** @class */ (function () {
    function IntersectionObserverModule() {
    }
IntersectionObserverModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IntersectionObserverModule });
IntersectionObserverModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IntersectionObserverModule_Factory(t) { return new (t || IntersectionObserverModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntersectionObserverModule, { declarations: [IntersectionObserverDirective, IntersectionObserveeDirective, IntersectionRootDirective], exports: [IntersectionObserverDirective, IntersectionObserveeDirective, IntersectionRootDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserverModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IntersectionObserverDirective,
                    IntersectionObserveeDirective,
                    IntersectionRootDirective,
                ],
                exports: [
                    IntersectionObserverDirective,
                    IntersectionObserveeDirective,
                    IntersectionRootDirective,
                ]
            }]
    }], function () { return []; }, null); })();
    return IntersectionObserverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var INTERSECTION_OBSERVER_SUPPORT = new InjectionToken('Intersection Observer API support', {
    providedIn: 'root',
    factory: function () { return !!inject(WINDOW).IntersectionObserver; },
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IntersectionObserverService = /** @class */ (function (_super) {
    __extends(IntersectionObserverService, _super);
    function IntersectionObserverService(_a, support, rootMargin, threshold, root) {
        var nativeElement = _a.nativeElement;
        var _this = _super.call(this, function (subscriber) {
            if (!support) {
                subscriber.error('IntersectionObserver is not supported in your browser');
                return;
            }
            /** @type {?} */
            var observer = new IntersectionObserver(function (entries) {
                subscriber.next(entries);
            }, {
                root: root && root.nativeElement,
                rootMargin: rootMargin,
                threshold: threshold,
            });
            observer.observe(nativeElement);
            return function () {
                observer.disconnect();
            };
        }) || this;
        return _this.pipe(share());
    }
    /** @nocollapse */
    IntersectionObserverService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Boolean, decorators: [{ type: Inject, args: [INTERSECTION_OBSERVER_SUPPORT,] }] },
        { type: String, decorators: [{ type: Inject, args: [INTERSECTION_ROOT_MARGIN,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [INTERSECTION_THRESHOLD,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INTERSECTION_ROOT,] }] }
    ]; };
IntersectionObserverService.ɵfac = function IntersectionObserverService_Factory(t) { return new (t || IntersectionObserverService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(INTERSECTION_OBSERVER_SUPPORT), ɵngcc0.ɵɵinject(INTERSECTION_ROOT_MARGIN), ɵngcc0.ɵɵinject(INTERSECTION_THRESHOLD), ɵngcc0.ɵɵinject(INTERSECTION_ROOT, 8)); };
IntersectionObserverService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntersectionObserverService, factory: function (t) { return IntersectionObserverService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserverService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }, { type: Boolean, decorators: [{
                type: Inject,
                args: [INTERSECTION_OBSERVER_SUPPORT]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [INTERSECTION_ROOT_MARGIN]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [INTERSECTION_THRESHOLD]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [INTERSECTION_ROOT]
            }] }]; }, null); })();
    return IntersectionObserverService;
}(Observable));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IntersectionObserveeDirective, IntersectionObserverDirective, IntersectionRootDirective, IntersectionObserverModule, IntersectionObserveeService, IntersectionObserverService, INTERSECTION_ROOT, INTERSECTION_ROOT_MARGIN_DEFAULT, INTERSECTION_ROOT_MARGIN, INTERSECTION_THRESHOLD_DEFAULT, INTERSECTION_THRESHOLD, INTERSECTION_OBSERVER_SUPPORT };

//# sourceMappingURL=ng-web-apis-intersection-observer.js.map