(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('rxjs'),exports, require('rxjs'), require('rxjs/operators'), require('@angular/core'), require('@ng-web-apis/common')) :
    typeof define === 'function' && define.amd ? define('@ng-web-apis/intersection-observer', ['@angular/core','rxjs','exports', 'rxjs', 'rxjs/operators', '@angular/core', '@ng-web-apis/common'], factory) :
    (factory(global.ng.core,global.rxjs,(global['ng-web-apis'] = global['ng-web-apis'] || {}, global['ng-web-apis']['intersection-observer'] = {}),global.rxjs,global.rxjs.operators,global.ng.core,global.common));
}(this, (function (ɵngcc0,ɵngcc1,exports,rxjs,operators,core,common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var INTERSECTION_ROOT = new core.InjectionToken('Root element for IntersectionObserver');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var INTERSECTION_ROOT_MARGIN_DEFAULT = '0px 0px 0px 0px';
    /** @type {?} */
    var INTERSECTION_ROOT_MARGIN = new core.InjectionToken('rootMargin for IntersectionObserver', {
        providedIn: 'root',
        factory: function () { return INTERSECTION_ROOT_MARGIN_DEFAULT; },
    });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} rootMargin
     * @return {?}
     */
    function rootMarginFactory(rootMargin) {
        return rootMargin || INTERSECTION_ROOT_MARGIN_DEFAULT;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var INTERSECTION_THRESHOLD_DEFAULT = 0;
    /** @type {?} */
    var INTERSECTION_THRESHOLD = new core.InjectionToken('threshold for IntersectionObserver', {
        providedIn: 'root',
        factory: function () { return INTERSECTION_THRESHOLD_DEFAULT; },
    });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} threshold
     * @return {?}
     */
    function thresholdFactory(threshold) {
        return threshold
            ? threshold.split(',').map(parseFloat)
            : INTERSECTION_THRESHOLD_DEFAULT;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IntersectionObserverDirective = /** @class */ (function (_super) {
        __extends(IntersectionObserverDirective, _super);
        function IntersectionObserverDirective(root, rootMargin, threshold) {
            var _this = _super.call(this, function (entries) {
                _this.callbacks.forEach(function (callback, element) {
                    /** @type {?} */
                    var filtered = entries.filter(function (_a) {
                        var target = _a.target;
                        return target === element;
                    });
                    return filtered.length && callback(filtered, _this);
                });
            }, {
                root: root && root.nativeElement,
                rootMargin: rootMarginFactory(rootMargin),
                threshold: thresholdFactory(threshold),
            }) || this;
            _this.callbacks = new Map();
            return _this;
        }
        /**
         * @param {?} target
         * @param {?=} callback
         * @return {?}
         */
        IntersectionObserverDirective.prototype.observe = /**
         * @param {?} target
         * @param {?=} callback
         * @return {?}
         */
            function (target, callback) {
                if (callback === void 0) {
                    callback = function () { };
                }
                _super.prototype.observe.call(this, target);
                this.callbacks.set(target, callback);
            };
        /**
         * @param {?} target
         * @return {?}
         */
        IntersectionObserverDirective.prototype.unobserve = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                _super.prototype.unobserve.call(this, target);
                this.callbacks.delete(target);
            };
        /**
         * @return {?}
         */
        IntersectionObserverDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.disconnect();
            };
        /** @nocollapse */
        IntersectionObserverDirective.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [INTERSECTION_ROOT,] }] },
                { type: undefined, decorators: [{ type: core.Attribute, args: ['waIntersectionRootMargin',] }] },
                { type: undefined, decorators: [{ type: core.Attribute, args: ['waIntersectionThreshold',] }] }
            ];
        };
IntersectionObserverDirective.ɵfac = function IntersectionObserverDirective_Factory(t) { return new (t || IntersectionObserverDirective)(ɵngcc0.ɵɵdirectiveInject(INTERSECTION_ROOT, 8), ɵngcc0.ɵɵinjectAttribute('waIntersectionRootMargin'), ɵngcc0.ɵɵinjectAttribute('waIntersectionThreshold')); };
IntersectionObserverDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IntersectionObserverDirective, selectors: [["", "waIntersectionObserver", ""]], exportAs: ["IntersectionObserver"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserverDirective, [{
        type: core.Directive,
        args: [{
                selector: '[waIntersectionObserver]',
                exportAs: 'IntersectionObserver'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [INTERSECTION_ROOT]
            }] }, { type: undefined, decorators: [{
                type: core.Attribute,
                args: ['waIntersectionRootMargin']
            }] }, { type: undefined, decorators: [{
                type: core.Attribute,
                args: ['waIntersectionThreshold']
            }] }]; }, null); })();
        return IntersectionObserverDirective;
    }(IntersectionObserver));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IntersectionObserveeService = /** @class */ (function (_super) {
        __extends(IntersectionObserveeService, _super);
        function IntersectionObserveeService(_a, observer) {
            var nativeElement = _a.nativeElement;
            var _this = _super.call(this, function (subscriber) {
                observer.observe(nativeElement, function (entries) {
                    subscriber.next(entries);
                });
                return function () {
                    observer.unobserve(nativeElement);
                };
            }) || this;
            return _this.pipe(operators.share());
        }
        /** @nocollapse */
        IntersectionObserveeService.ctorParameters = function () {
            return [
                { type: core.ElementRef, decorators: [{ type: core.Inject, args: [core.ElementRef,] }] },
                { type: IntersectionObserverDirective, decorators: [{ type: core.Inject, args: [IntersectionObserverDirective,] }] }
            ];
        };
IntersectionObserveeService.ɵfac = function IntersectionObserveeService_Factory(t) { return new (t || IntersectionObserveeService)(ɵngcc0.ɵɵinject(core.ElementRef), ɵngcc0.ɵɵinject(IntersectionObserverDirective)); };
IntersectionObserveeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntersectionObserveeService, factory: function (t) { return IntersectionObserveeService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserveeService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: core.Inject,
                args: [core.ElementRef]
            }] }, { type: IntersectionObserverDirective, decorators: [{
                type: core.Inject,
                args: [IntersectionObserverDirective]
            }] }]; }, null); })();
        return IntersectionObserveeService;
    }(rxjs.Observable));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // @dynamic
    var IntersectionObserveeDirective = /** @class */ (function () {
        function IntersectionObserveeDirective(waIntersectionObservee) {
            this.waIntersectionObservee = waIntersectionObservee;
        }
        /** @nocollapse */
        IntersectionObserveeDirective.ctorParameters = function () {
            return [
                { type: rxjs.Observable, decorators: [{ type: core.Inject, args: [IntersectionObserveeService,] }] }
            ];
        };
IntersectionObserveeDirective.ɵfac = function IntersectionObserveeDirective_Factory(t) { return new (t || IntersectionObserveeDirective)(ɵngcc0.ɵɵdirectiveInject(IntersectionObserveeService)); };
IntersectionObserveeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IntersectionObserveeDirective, selectors: [["", "waIntersectionObservee", ""]], outputs: { waIntersectionObservee: "waIntersectionObservee" }, features: [ɵngcc0.ɵɵProvidersFeature([IntersectionObserveeService])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserveeDirective, [{
        type: core.Directive,
        args: [{
                selector: '[waIntersectionObservee]',
                outputs: ['waIntersectionObservee'],
                providers: [IntersectionObserveeService]
            }]
    }], function () { return [{ type: ɵngcc1.Observable, decorators: [{
                type: core.Inject,
                args: [IntersectionObserveeService]
            }] }]; }, null); })();
        return IntersectionObserveeDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IntersectionRootDirective = /** @class */ (function () {
        function IntersectionRootDirective() {
        }
IntersectionRootDirective.ɵfac = function IntersectionRootDirective_Factory(t) { return new (t || IntersectionRootDirective)(); };
IntersectionRootDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IntersectionRootDirective, selectors: [["", "waIntersectionRoot", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: INTERSECTION_ROOT,
                useExisting: core.ElementRef
            },
        ])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionRootDirective, [{
        type: core.Directive,
        args: [{
                selector: '[waIntersectionRoot]',
                providers: [
                    {
                        provide: INTERSECTION_ROOT,
                        useExisting: core.ElementRef
                    },
                ]
            }]
    }], function () { return []; }, null); })();
        return IntersectionRootDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IntersectionObserverModule = /** @class */ (function () {
        function IntersectionObserverModule() {
        }
IntersectionObserverModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IntersectionObserverModule });
IntersectionObserverModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IntersectionObserverModule_Factory(t) { return new (t || IntersectionObserverModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntersectionObserverModule, { declarations: [IntersectionObserverDirective, IntersectionObserveeDirective, IntersectionRootDirective], exports: [IntersectionObserverDirective, IntersectionObserveeDirective, IntersectionRootDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserverModule, [{
        type: core.NgModule,
        args: [{
                declarations: [
                    IntersectionObserverDirective,
                    IntersectionObserveeDirective,
                    IntersectionRootDirective,
                ],
                exports: [
                    IntersectionObserverDirective,
                    IntersectionObserveeDirective,
                    IntersectionRootDirective,
                ]
            }]
    }], function () { return []; }, null); })();
        return IntersectionObserverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var INTERSECTION_OBSERVER_SUPPORT = new core.InjectionToken('Intersection Observer API support', {
        providedIn: 'root',
        factory: function () { return !!core.inject(common.WINDOW).IntersectionObserver; },
    });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IntersectionObserverService = /** @class */ (function (_super) {
        __extends(IntersectionObserverService, _super);
        function IntersectionObserverService(_a, support, rootMargin, threshold, root) {
            var nativeElement = _a.nativeElement;
            var _this = _super.call(this, function (subscriber) {
                if (!support) {
                    subscriber.error('IntersectionObserver is not supported in your browser');
                    return;
                }
                /** @type {?} */
                var observer = new IntersectionObserver(function (entries) {
                    subscriber.next(entries);
                }, {
                    root: root && root.nativeElement,
                    rootMargin: rootMargin,
                    threshold: threshold,
                });
                observer.observe(nativeElement);
                return function () {
                    observer.disconnect();
                };
            }) || this;
            return _this.pipe(operators.share());
        }
        /** @nocollapse */
        IntersectionObserverService.ctorParameters = function () {
            return [
                { type: core.ElementRef, decorators: [{ type: core.Inject, args: [core.ElementRef,] }] },
                { type: Boolean, decorators: [{ type: core.Inject, args: [INTERSECTION_OBSERVER_SUPPORT,] }] },
                { type: String, decorators: [{ type: core.Inject, args: [INTERSECTION_ROOT_MARGIN,] }] },
                { type: undefined, decorators: [{ type: core.Inject, args: [INTERSECTION_THRESHOLD,] }] },
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [INTERSECTION_ROOT,] }] }
            ];
        };
IntersectionObserverService.ɵfac = function IntersectionObserverService_Factory(t) { return new (t || IntersectionObserverService)(ɵngcc0.ɵɵinject(core.ElementRef), ɵngcc0.ɵɵinject(INTERSECTION_OBSERVER_SUPPORT), ɵngcc0.ɵɵinject(INTERSECTION_ROOT_MARGIN), ɵngcc0.ɵɵinject(INTERSECTION_THRESHOLD), ɵngcc0.ɵɵinject(INTERSECTION_ROOT, 8)); };
IntersectionObserverService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntersectionObserverService, factory: function (t) { return IntersectionObserverService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserverService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: core.Inject,
                args: [core.ElementRef]
            }] }, { type: Boolean, decorators: [{
                type: core.Inject,
                args: [INTERSECTION_OBSERVER_SUPPORT]
            }] }, { type: String, decorators: [{
                type: core.Inject,
                args: [INTERSECTION_ROOT_MARGIN]
            }] }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [INTERSECTION_THRESHOLD]
            }] }, { type: undefined, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [INTERSECTION_ROOT]
            }] }]; }, null); })();
        return IntersectionObserverService;
    }(rxjs.Observable));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.IntersectionObserveeDirective = IntersectionObserveeDirective;
    exports.IntersectionObserverDirective = IntersectionObserverDirective;
    exports.IntersectionRootDirective = IntersectionRootDirective;
    exports.IntersectionObserverModule = IntersectionObserverModule;
    exports.IntersectionObserveeService = IntersectionObserveeService;
    exports.IntersectionObserverService = IntersectionObserverService;
    exports.INTERSECTION_ROOT = INTERSECTION_ROOT;
    exports.INTERSECTION_ROOT_MARGIN_DEFAULT = INTERSECTION_ROOT_MARGIN_DEFAULT;
    exports.INTERSECTION_ROOT_MARGIN = INTERSECTION_ROOT_MARGIN;
    exports.INTERSECTION_THRESHOLD_DEFAULT = INTERSECTION_THRESHOLD_DEFAULT;
    exports.INTERSECTION_THRESHOLD = INTERSECTION_THRESHOLD;
    exports.INTERSECTION_OBSERVER_SUPPORT = INTERSECTION_OBSERVER_SUPPORT;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ng-web-apis-intersection-observer.umd.js.map